// =============================================================================
// Generated by efx_ipmgr
// Version: 2020.M.314
// IP Version: 2.0
// =============================================================================

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//                                                                       
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//                                                                       
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.                                                
//
////////////////////////////////////////////////////////////////////////////////

module efx_i2c_master_controller (
    clk,
    rst,
    mst_scl_in,
    mst_sda_in,
    mst_scl_out,
    mst_sda_out,
    mst_sda_oe,
    mst_scl_oe,
    mst_data_out,
    i2c_busy,
    i2c_soft_rst,
    i2c_rxak,
    i2c_arb_lost,
    i2c_arb_lost_clr,
    mst_din,
    i2c_slave_addr,
    mst_command_byte,
    mst_num_bytes,
    mst_read,
    mst_write,
    mst_write_done,
    mst_data_out_valid
);

    `include "I2C_Master_define.vh"

    input clk;
    input rst;
    input mst_scl_in;
    input mst_sda_in;
    output mst_scl_out;
    output mst_sda_out;
    output mst_sda_oe;
    output mst_scl_oe;
    output [DATA_BYTE_WIDTH-1:0] mst_data_out;
    output i2c_busy;
    input i2c_soft_rst;
    output i2c_rxak;
    output i2c_arb_lost;
    input i2c_arb_lost_clr;
    input [DATA_BYTE_WIDTH-1:0] mst_din;
    input [7:0] i2c_slave_addr;
    input [7:0] mst_command_byte;
    input [7:0] mst_num_bytes;
    input mst_read;
    input mst_write;
    output mst_write_done;
    output mst_data_out_valid;

    i2c_controller_42020d0b46f7431cb398735cd4a68ca0 #(
        .CLOCK_FREQ ( CLOCK_FREQ ),
        .DATA_BYTE_WIDTH ( DATA_BYTE_WIDTH ),
        .I2C_FAST_MODE ( I2C_FAST_MODE ),
        .I2C_MODE ( "MASTER" ),
        .SPIKE_FILTER_CYCLE ( SPIKE_FILTER_CYCLE ),
        .SLAVE_ADDR ( SLAVE_ADDR )
    ) i2c_controller_u (
        .clk ( clk ),
        .rst ( rst ),
        .mst_scl_in ( mst_scl_in ),
        .mst_sda_in ( mst_sda_in ),
        .mst_scl_out ( mst_scl_out ),
        .mst_sda_out ( mst_sda_out ),
        .mst_sda_oe ( mst_sda_oe ),
        .mst_scl_oe ( mst_scl_oe ),
        .mst_data_out ( mst_data_out ),
        .i2c_busy ( i2c_busy ),
        .i2c_soft_rst ( i2c_soft_rst ),
        .i2c_rxak ( i2c_rxak ),
        .i2c_arb_lost ( i2c_arb_lost ),
        .i2c_arb_lost_clr ( i2c_arb_lost_clr ),
        .mst_din ( mst_din ),
        .i2c_slave_addr ( i2c_slave_addr ),
        .mst_command_byte ( mst_command_byte ),
        .mst_num_bytes ( mst_num_bytes ),
        .mst_read ( mst_read ),
        .mst_write ( mst_write ),
        .mst_write_done ( mst_write_done ),
        .mst_data_out_valid ( mst_data_out_valid )
    );

endmodule

/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   i2c_controller_42020d0b46f7431cb398735cd4a68ca0.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      I2c controller top module
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns / 1ps


module i2c_controller_42020d0b46f7431cb398735cd4a68ca0 (
	clk,
    rst,
    mst_scl_in,
    mst_sda_in,
    mst_scl_out,
    mst_sda_out,
    mst_sda_oe,
    mst_scl_oe,
    mst_data_out,
    mst_data_out_valid,
    i2c_busy,
    i2c_soft_rst,
    i2c_rxak,
    i2c_arb_lost,
    i2c_arb_lost_clr,
    mst_din,
    i2c_slave_addr,
    mst_command_byte,
    mst_num_bytes,
    mst_read,
    mst_write,
    mst_write_done,
    slv_scl_in,
    slv_sda_in,
    slv_scl_out,
    slv_scl_oe,
    slv_sda_out,
    slv_sda_oe,
    slv_data_out,
    slv_command_byte,
    slv_din,
    slv_read,
    slv_write,
    slv_busy,
    slv_ready_to_wr,
    slv_ready_to_rd,
    slv_rddata_valid
);
    parameter CLOCK_FREQ = 100;
    parameter DATA_BYTE_WIDTH = 32;
    parameter I2C_FAST_MODE = 1; 
    parameter SPIKE_FILTER_CYCLE = 2;
    parameter SLAVE_ADDR = 8'h54;
    parameter I2C_MODE = "MASTER";
    
	//master
	//I2c Interfacing. 
    output wire   	                  mst_scl_out;
    output wire  	                  mst_scl_oe;     
    input 		                  mst_scl_in;
    
    output wire		                  mst_sda_out;
    output wire		                  mst_sda_oe;   
    input 		                  mst_sda_in;

    input 			              clk;	
    input  		                  rst;		//Sync Reset.
    output wire[DATA_BYTE_WIDTH-1:0]   mst_data_out;	//32-bits data to Microcontroller/User Logic
	output wire                   mst_data_out_valid;
    input [DATA_BYTE_WIDTH-1:0]   mst_din;		//32-bits from Microcontroller / User Logic FSM. 
    input [7:0] 	              mst_command_byte;	//Command Bytes 
    input [7:0] 		          mst_num_bytes;	//Number of Read/Write Bytes. 
    input 			              mst_read;		//Read Strobe. 
    input 			              mst_write;		//Write Strobe.
    output wire                   mst_write_done;
	
	input 			              i2c_soft_rst;	//I2c Soft Reset.
    output wire 	    		          i2c_busy;	//i2c busy.
	output wire                       i2c_arb_lost;
    output wire      		          i2c_rxak; //i2c acknowledge.
    input                         i2c_arb_lost_clr;
    input [7:0]                   i2c_slave_addr;	//i2c slave address register.
    
    //slave
    
    output wire	                      slv_sda_out;
    output wire                       slv_sda_oe;
    input 		                  slv_sda_in;
    
    output wire	                      slv_scl_out;
    output wire                       slv_scl_oe;
    input 		                  slv_scl_in;
    
    //Microcontroller interface
    input                         slv_read;     //Read Strobe from Microcontroller
    input                         slv_write;    //write Strobe from Microcontroller
    input [DATA_BYTE_WIDTH-1:0]   slv_din;		//32-bits from Microcontroller / User Logic FSM. 
    output wire[DATA_BYTE_WIDTH-1:0]  slv_data_out;	    //32-bits data to Microcontroller/User Logic. 
    output wire [7:0]                 slv_command_byte;
    
    output wire                       slv_busy;
    output wire                       slv_ready_to_wr;  //user should write only when this bit is high; else the previous data will be override
    output wire                       slv_ready_to_rd;
    output wire                       slv_rddata_valid;  
							

  generate
   if (I2C_MODE == "MASTER")
   i2c_master_ctl_42020d0b46f7431cb398735cd4a68ca0 #(
      .DATA_BYTE_WIDTH (DATA_BYTE_WIDTH),
      .I2C_FAST_MODE (I2C_FAST_MODE),
      .CLOCK_FREQ (CLOCK_FREQ),
      .SPIKE_FILTER_CYCLE (SPIKE_FILTER_CYCLE)
   ) master_ctl_inst (
    .scl_out          (mst_scl_out),
    .sda_out          (mst_sda_out),
    .sda_in           (mst_sda_in),
    .scl_in           (mst_scl_in), 
    .sda_oe           (mst_sda_oe),
    .scl_oe           (mst_scl_oe),
    .data_out         (mst_data_out),
    .data_out_valid   (mst_data_out_valid),
    .i2c_busy         (i2c_busy),
    .i2c_rxak         (i2c_rxak),
    .i2c_arb_lost     (i2c_arb_lost),
	.i2c_arb_lost_clr (i2c_arb_lost_clr),
    .din              (mst_din),
    .clk              (clk),
    .rst              (rst),
    .i2c_slave_addr   (i2c_slave_addr),
    .command_byte     (mst_command_byte),
    .num_bytes        (mst_num_bytes),
    .read             (mst_read),
    .write            (mst_write),
    .write_done       (mst_write_done),
    .i2c_soft_rst     (i2c_soft_rst));
   else if (I2C_MODE == "SLAVE")
   i2c_slave_ctl_42020d0b46f7431cb398735cd4a68ca0  #(
      .DATA_BYTE_WIDTH (DATA_BYTE_WIDTH),
      .SLAVE_ADDR (SLAVE_ADDR),
      .I2C_FAST_MODE (I2C_FAST_MODE),
      .CLOCK_FREQ (CLOCK_FREQ),
      .SPIKE_FILTER_CYCLE (SPIKE_FILTER_CYCLE)
   ) slave_ctl_inst (
    .sda_out      (slv_sda_out),
    .sda_in       (slv_sda_in),
    .scl_in       (slv_scl_in),
    .scl_out      (slv_scl_out),    
    .sda_oe       (slv_sda_oe),
    .scl_oe       (slv_scl_oe),
    .clk          (clk),
    .rst          (rst),
    .read         (slv_read),
    .write        (slv_write),
    .din          (slv_din),
    .data_out     (slv_data_out),
    .command_byte (slv_command_byte),
    .busy         (slv_busy),
    .ready_to_wr  (slv_ready_to_wr),
    .ready_to_rd  (slv_ready_to_rd),
    .rddata_valid (slv_rddata_valid)
);
endgenerate

endmodule
    
/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   i2c_master_ctl_42020d0b46f7431cb398735cd4a68ca0.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      I2c master controller top module
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************
`resetall
`timescale 1ns / 1ps

module i2c_master_ctl_42020d0b46f7431cb398735cd4a68ca0
#(
    parameter DATA_BYTE_WIDTH = 32,
    parameter I2C_FAST_MODE = 0,  // 1 - 400khz, 0 - 100khz
    parameter CLOCK_FREQ = 100,   // support 2 - 150Mhz, 1 - 100Mhz, 0 - 50Mhz 
    parameter SPIKE_FILTER_CYCLE = 2
) (
    //I2c Interfacing. 
    output wire  	                  scl_out, 
    output wire  	                  scl_oe,     
    input 			                  scl_in,
    
    output wire		                  sda_out,
    output wire		                  sda_oe,    
    input 			                  sda_in,

    input 			                  clk,	
    input 			                  rst,		//Sync Reset.
    output wire [DATA_BYTE_WIDTH-1:0] data_out,	//32-bits data to Microcontroller/User Logic
    output wire                       data_out_valid,
	input [DATA_BYTE_WIDTH-1:0]       din,		//32-bits from Microcontroller / User Logic FSM. 
    input [7:0] 	                  command_byte,	//Command Bytes 
    input [7:0] 		              num_bytes,	//Number of Read/Write Bytes. 
    input 			                  read,		//Read Strobe. 
    input 			                  write,		//Write Strobe.
    output wire                       write_done,
	
	input 			                  i2c_soft_rst,	//I2c Soft Reset.
    output wire 		              i2c_busy,	//i2c busy.
	output wire                       i2c_arb_lost,
    output wire 		              i2c_rxak, //i2c acknowledge.
    input                             i2c_arb_lost_clr,
    input [7:0] 		              i2c_slave_addr	//i2c slave address register.
							
   ); 

// Local Parameter (FSM)
   //== State enumeration
   parameter [3:0] // synopsys enum state_info
     IDLE_ST          = 4'h0,
     START_GEN0_ST    = 4'h1,
     WRITE_CMDBYTE0_ST= 4'h2,
     WRITE_DAT0_ST    = 4'h3,
     START_GEN1_ST    = 4'h4,
     WRITE_CMDBYTE1_ST= 4'h5, 
     RESTART_ST       = 4'h6, // Generate a restart sequence
     WRITE_DAT2_ST    = 4'h7, // READ THE DATA
     STOP_GEN_ST      = 4'h8,
     DONE_ST          = 4'h9;
   
	      
   
	      
//internal signals
   //== State variables
   reg [3:0] /* synopsys enum state_info */ 
	     current_st; /* synopsys state_vector current_st */ 
   reg [3:0] /* synopsys enum state_info */			      
	     next_st;
   
   reg [7:0] byte_cnt;  //Byte Counter.    
   reg [7:0]  MIDR; //I2d Data Register Inbound
   reg [7:0]  MBCR; //Control Register
   wire [7:0] MBSR; //Status Register. 
   wire [7:0] MODR; //I2c Data Register Outbound
   wire       uc_wr_data;
   wire       uc_rd_data;
   reg [1:0]  mbcr_write0;
   reg 	      mbcr_write;
   wire       wuc0;
   reg 	      wuc1;
   wire       xfer_complete0;
   reg 	      xfer_complete1;
   reg 	      xfer_complete2;
   reg 	      restart;
   reg 	      mbcr_write_a;
   reg [1:0]  uc_wr_data0;
   reg [1:0]  uc_rd_data0;
   reg [7:0]  i2c_slave_addr0;
   wire       read_p,write_p;   
   reg [3:0]  soft_rst_reg;
   wire       soft_rst;
   reg [DATA_BYTE_WIDTH-1:0] data_out0;
   reg [2:0]  data_cnt;
   wire reset_cnt;   
   wire load_xfer, i2c_read;
   
   assign scl_oe = ~scl_out;
   assign sda_oe = ~sda_out;
   
   assign load_xfer = xfer_complete2 && ~xfer_complete1;
   
   //////////////////////////////////////////////////////////////////////////////////////
   //Sensor Status update.
   //This state machine is actually used to solve performance issues caused by firmware.
   ///////////////////////////////////////////////////////////////////////////////////////

   //I2C Receive Acknowledge Bit
   assign i2c_rxak = MBSR[0];
      
   // I2c Busy status
   assign i2c_busy = MBSR[5];
   
   // I2c master arbitration lost
   assign i2c_arb_lost = MBSR[4];
   
   // I2C master read
   assign i2c_read = ~MBCR[4];
   
   /////////////////////////////////////
   //Sychronizer
   //Fast2Slow Domain
   /////////////////////////////////////
   pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0 u_pgfts_wrflag
     (
      // Outputs
      .data_out				(write_p),
      // Inputs
      .clk				    (clk),
      .rst                  (rst),
      .data_in				(write));
   
   pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0 u_pgfts_rdflag
     (
      // Outputs
      .data_out				(read_p),
      // Inputs
      .clk				    (clk),
      .rst                  (rst),
      .data_in				(read));
   
   /////////////////////////////
   //I2c Controller
   /////////////////////////////
   
   i2c_mstrslv_ctl_42020d0b46f7431cb398735cd4a68ca0 #(
      .I2C_FAST_MODE (I2C_FAST_MODE),
      .CLOCK_FREQ (CLOCK_FREQ),
      .SPIKE_FILTER_CYCLE (SPIKE_FILTER_CYCLE)
   ) u_i2c_mstrslv_ctl
     (
      // Outputs
      .MBSR				(MBSR[7:0]),		//I2c Status Register.
      .MODR				(MODR[7:0]),		//I2c Data Register
      .sda_out				(sda_out),		//SDA output drive control.
      .scl_out				(scl_out),		//SCL output drive control.
      // Inputs
      .restart          (restart),
      .MBCR				(MBCR[7:0]),		//i2c control register.
      .MADR				(i2c_slave_addr0),	//I2c Slave Address Register
      .MIDR				(MIDR[7:0]),		//I2c Data Register Inbound.
      .sda_in				(sda_in),		//SDA Input.
      .scl_in				(scl_in),		//SCL input.
      .mbcr_wr	         		(mbcr_write0[1]),	//MBCR is being written
      .uc_rd_data			(uc_rd_data),		//Status uC read data register.
      .uc_wr_data			(uc_wr_data),		//Status uC wrote data register.
      .mif_clr				(1'b0),			//Clear Interrupt Bit
      .mal_clr				(i2c_arb_lost_clr),			//Clear Arbitration Lost Bit.
      .clk				(clk));		//2MHz clock.
   

   ///////////////////////////////
   //I2c Slave Address.
   ///////////////////////////////
   always @(posedge clk)
     if (rst)
       i2c_slave_addr0 <= 8'h00;
     else /*if (read_p || write_p)*/ //Fix-Me !!!
       i2c_slave_addr0 <= i2c_slave_addr;

   ///////////////////////////////
   //I2c Master Controller States
   ///////////////////////////////
   always @(posedge clk)
     begin
	if (rst)
	  current_st <= IDLE_ST;
	else
	  current_st <= next_st;
     end
   
   always @(*)
     begin
	next_st = IDLE_ST;
	case(current_st)
	  
	  IDLE_ST: begin
	     if (write_p) 
	       next_st = START_GEN0_ST;  //I2c Master XMIT 
	     else if (read_p)
	       next_st = START_GEN1_ST;  //I2c Master Receive
	     else
	       next_st = IDLE_ST;
	  end
	  
	  START_GEN0_ST: begin //Generate Start Condition (XMIT)
	     if (write_p || read_p)
      	     next_st = STOP_GEN_ST;   
	     else if (MBSR[7] == 1'b1) // Wait for transfer complete
	         next_st = WRITE_CMDBYTE0_ST;
	     else
	         next_st = START_GEN0_ST;
	  end
	  
	  START_GEN1_ST: begin //Generate Start Condition (RECEIVER)
	     if (write_p || read_p)
           next_st = STOP_GEN_ST;   
	     else if (MBSR[7] == 1'b1)
	       next_st = WRITE_CMDBYTE1_ST;
	     else
	       next_st = START_GEN1_ST;
	  end
	  
	  WRITE_CMDBYTE0_ST: begin
	     if (write_p || read_p)
             next_st = STOP_GEN_ST;  
	     else if (MBSR[7] == 1'b1) // Wait for transfer complete
	         next_st = WRITE_DAT0_ST;
	     else
	         next_st = WRITE_CMDBYTE0_ST;
	  end
	  
	  WRITE_CMDBYTE1_ST: begin
	     if (write_p || read_p)
             next_st = STOP_GEN_ST;  
	     else if (MBSR[7] == 1'b1) // Wait for transfer complete
	         next_st = RESTART_ST;
	     else
	         next_st = WRITE_CMDBYTE1_ST;
	  end
	  
	  WRITE_DAT0_ST: begin
	     if (write_p || read_p)
	       begin 
      		  next_st = STOP_GEN_ST;  
	       end
	     else if (byte_cnt == (num_bytes-1) && MBSR[7] == 1'b1) //Wait for (data) xfer bit true
	       begin
		  next_st = STOP_GEN_ST;
	       end
	     else
	       begin
		  next_st = WRITE_DAT0_ST;
	       end // else: !if(byte_cnt == num_bytes && MBSR[7] == 1'b1)
	  end
	  
	  RESTART_ST : begin //Generate a restart sequence for read.
	     if (MBSR[7] == 1'b1)
	       next_st = WRITE_DAT2_ST;
	     else
	       next_st = RESTART_ST;
	  end
	  
	  WRITE_DAT2_ST: begin
	     if (read_p || write_p)
	       begin
		  next_st = STOP_GEN_ST;
	       end
	     else if ( (byte_cnt == (num_bytes - 1) ) && MBSR[7] == 1'b1) //Wait for (data) xfer bit true // minus 1 because no command byte
	       begin
		  next_st = STOP_GEN_ST;
	       end
	     else
	       begin
		  next_st = WRITE_DAT2_ST;
	       end // else: !if(byte_cnt == (num_bytes -1) && MBSR[7] == 1'b1)
	  end // case: WRITE_DAT2_ST
	  
	  
	  STOP_GEN_ST: begin 
	     if (MBSR[7] == 1'b0) //Wait for master to exit wait state
	       next_st = DONE_ST;
	     else
	       next_st = STOP_GEN_ST;
	  end
	  
	  DONE_ST: begin          //Check for MBB status flag.
	     if (MBSR[5] == 1'b0) //Wait for bus not busy
	       next_st = IDLE_ST;
	     else
	       next_st = DONE_ST;
	  end
  
	  default : next_st = IDLE_ST;
	endcase // case (current_st)	
     end // always @ (*)
   

     
//I2c Master Controller (WRITE-RESTART-READ)...   
//Note : Master Restart Read - This routine writes out the header and one data byte then generates a
// restart with another header and reads the data (based on the num_bytes setting)....
generate 
if (DATA_BYTE_WIDTH == 8) begin
    assign reset_cnt = (data_cnt == 1 || byte_cnt == num_bytes || current_st == IDLE_ST) ? 1'b1 : 1'b0;
    assign write_done = (data_cnt == 0) && (current_st == WRITE_DAT0_ST) && xfer_complete0 && ~xfer_complete1;
    assign data_out_valid = ((data_cnt == 1) && (current_st == WRITE_DAT2_ST) && ~xfer_complete0 && xfer_complete1) || (i2c_read && current_st == STOP_GEN_ST && ~xfer_complete0 && xfer_complete1);
    
    //Send data out!
    always @(posedge clk) begin
        if (rst) MIDR <= 8'h00;
        else if (write_p || read_p)               MIDR <= {i2c_slave_addr0[7:1],1'b0}; //Header + Write
        else if (current_st == RESTART_ST)        MIDR <= {i2c_slave_addr0[7:1],1'b1}; //Header + Read_p
        else if (current_st == WRITE_CMDBYTE0_ST || current_st == WRITE_CMDBYTE1_ST)  MIDR <= command_byte[7:0];
        else if (current_st == WRITE_DAT0_ST) begin
	        MIDR <= din[7:0];
	    end
	end
end
else if (DATA_BYTE_WIDTH == 16) begin
    assign reset_cnt = (data_cnt == 2 || byte_cnt == num_bytes || current_st == IDLE_ST) ? 1'b1 : 1'b0;
    assign write_done = (data_cnt == 1) && (current_st == WRITE_DAT0_ST) && xfer_complete0 && ~xfer_complete1;
    assign data_out_valid = ((data_cnt == 2) && (current_st == WRITE_DAT2_ST) && ~xfer_complete0 && xfer_complete1) || (i2c_read && current_st == STOP_GEN_ST && ~xfer_complete0 && xfer_complete1);
    
    //Send data out!
    always @(posedge clk) begin
        if (rst) MIDR <= 8'h00;
        else if (write_p || read_p)               MIDR <= {i2c_slave_addr0[7:1],1'b0}; //Header + Write
        else if (current_st == RESTART_ST)        MIDR <= {i2c_slave_addr0[7:1],1'b1}; //Header + Read_p
        else if (current_st == WRITE_CMDBYTE0_ST || current_st == WRITE_CMDBYTE1_ST)  MIDR <= command_byte[7:0];
        else if (current_st == WRITE_DAT0_ST) begin
	        if (data_cnt == 0)      MIDR <= din[7:0];
	        else if (data_cnt == 1) MIDR <= din[15:8];
	    end
	end
end
else if (DATA_BYTE_WIDTH == 24) begin
    assign reset_cnt = (data_cnt == 3 || byte_cnt == num_bytes || current_st == IDLE_ST) ? 1'b1 : 1'b0;
    assign write_done = (data_cnt == 2) && (current_st == WRITE_DAT0_ST) && xfer_complete0 && ~xfer_complete1;
    assign data_out_valid = ((data_cnt == 3) && (current_st == WRITE_DAT2_ST) && ~xfer_complete0 && xfer_complete1) || (i2c_read && current_st == STOP_GEN_ST && ~xfer_complete0 && xfer_complete1);
    
    //Send data out!
    always @(posedge clk) begin
        if (rst) MIDR <= 8'h00;
        else if (write_p || read_p)               MIDR <= {i2c_slave_addr0[7:1],1'b0}; //Header + Write
        else if (current_st == RESTART_ST)        MIDR <= {i2c_slave_addr0[7:1],1'b1}; //Header + Read_p
        else if (current_st == WRITE_CMDBYTE0_ST || current_st == WRITE_CMDBYTE1_ST)  MIDR <= command_byte[7:0];
        else if (current_st == WRITE_DAT0_ST) begin
	        if (data_cnt == 0)      MIDR <= din[7:0];
	        else if (data_cnt == 1) MIDR <= din[15:8];
	        else if (data_cnt == 2) MIDR <= din[23:16];
	    end
	end
end
else if (DATA_BYTE_WIDTH == 32) begin
    assign reset_cnt = (data_cnt == 4 || byte_cnt == num_bytes || current_st == IDLE_ST) ? 1'b1 : 1'b0;
    assign write_done = (data_cnt == 3) && (current_st == WRITE_DAT0_ST) && xfer_complete0 && ~xfer_complete1;
    assign data_out_valid = ((data_cnt == 4) && (current_st == WRITE_DAT2_ST) && ~xfer_complete0 && xfer_complete1) || (i2c_read && current_st == STOP_GEN_ST && ~xfer_complete0 && xfer_complete1);
    
    //Send data out!
    always @(posedge clk) begin
        if (rst) MIDR <= 8'h00;
        else if (write_p || read_p)               MIDR <= {i2c_slave_addr0[7:1],1'b0}; //Header + Write
        else if (current_st == RESTART_ST)        MIDR <= {i2c_slave_addr0[7:1],1'b1}; //Header + Read_p
        else if (current_st == WRITE_CMDBYTE0_ST || current_st == WRITE_CMDBYTE1_ST)  MIDR <= command_byte[7:0];
        else if (current_st == WRITE_DAT0_ST) begin
	        if (data_cnt == 0)      MIDR <= din[7:0];
	        else if (data_cnt == 1) MIDR <= din[15:8];
	        else if (data_cnt == 2) MIDR <= din[23:16];
	        else if (data_cnt == 3) MIDR <= din[31:24];
	    end
	end
end
endgenerate
   
   //I2c Master Control Register
   always @(posedge clk)
     if (rst | soft_rst)
       MBCR <= 8'h00;
     else if ( (current_st == WRITE_DAT0_ST || current_st == WRITE_CMDBYTE0_ST) && (read_p || write_p) ) 
       MBCR <= 8'hD0; //Generate a stop conditon... for TX
     else if ( (current_st == WRITE_CMDBYTE1_ST  || current_st == WRITE_DAT2_ST) && (read_p || write_p) ) 
       MBCR <= 8'hC0; //Generate a stop conditon... for RX
     else if (current_st == START_GEN0_ST || current_st == START_GEN1_ST)
       MBCR <= 8'hf0; // Generate Start Conditon (write cycle)
     else if ( current_st == RESTART_ST && next_st != WRITE_DAT2_ST)// && next_st != RESTART_ST)
       MBCR <= 8'hE4; //Generate a restart read with ack
     else if ((current_st == WRITE_DAT2_ST || (current_st == RESTART_ST && next_st == WRITE_DAT2_ST)) && byte_cnt == (num_bytes -2) && MBCR !== 8'hc0 && MBSR[7] == 1'b1) //4
       MBCR <= 8'hE8; // Generate(end multibyte read cycle noack!)
     else if ( (current_st == WRITE_DAT2_ST) && byte_cnt == (num_bytes -1) && MBSR[7] == 1'b1 ) //5
       MBCR <= 8'hC0; // Generate a STOP Condition for RX
     else if ( (current_st == WRITE_DAT0_ST) && byte_cnt == (num_bytes -1) && MBSR[7] == 1'b1 )
       MBCR <= 8'hD0; // Generate a STOP Condition for TX
       
   always @(posedge clk)
     if (rst | soft_rst)
       mbcr_write0 <= 2'b00;
     else if ( (current_st == WRITE_DAT0_ST || current_st == WRITE_CMDBYTE0_ST || current_st == WRITE_CMDBYTE1_ST || current_st == WRITE_DAT2_ST ) && (read_p || write_p) ) 
       mbcr_write0 <= 2'b11;
     else if ((current_st != START_GEN0_ST && next_st == START_GEN0_ST)|| (current_st != START_GEN1_ST && next_st == START_GEN1_ST))
       mbcr_write0 <= 2'b11;
     else if (current_st != RESTART_ST && next_st == RESTART_ST)
       mbcr_write0 <= 2'b11;
     else if ((current_st == WRITE_DAT2_ST) && byte_cnt == (num_bytes -2) && MBCR !== 8'hc0 && MBSR[7] == 1'b1) //4
       mbcr_write0 <= 2'b11;
     else if ( (current_st == WRITE_DAT2_ST) && byte_cnt == (num_bytes -1) && MBSR[7] == 1'b1 ) //5
       mbcr_write0 <= 2'b11;
     else if ( (current_st == WRITE_DAT0_ST) && byte_cnt == (num_bytes -1) && MBSR[7] == 1'b1 )
       mbcr_write0 <= 2'b11;
     else
       mbcr_write0 <= {mbcr_write0[0],1'b0}; 
   
   always @(posedge clk)
     begin
	if (rst)
	  restart <= 1'b0;
	else
      restart <= (next_st == RESTART_ST && current_st != RESTART_ST);
     end

   always @(posedge clk)
     if (rst)
       begin
	  mbcr_write_a <= 1'b0;
	  mbcr_write   <= 1'b0;
       end
     else    
       begin 
	  mbcr_write_a <= mbcr_write0[1];
	  mbcr_write <= mbcr_write_a;
       end
   
   
   assign wuc0 = MBSR[3];
   assign xfer_complete0 = MBSR[7];
   
   always @(posedge clk)
     if (rst)
       begin
	  wuc1 <= 1'b0;
	  xfer_complete1 <= 1'b0;
	  xfer_complete2 <= 1'b0;
       end
     else
       begin
	  wuc1 <= wuc0;
	  xfer_complete1 <= xfer_complete0;
	  xfer_complete2 <= xfer_complete1;
      end
   
   //I2c Write Strobe
   always @(posedge clk)
     if (rst)
       uc_wr_data0 <= 2'b0;
     else if (next_st == RESTART_ST && current_st != RESTART_ST) 
       uc_wr_data0 <= 2'b11;
     else if (next_st == WRITE_CMDBYTE0_ST && current_st != WRITE_CMDBYTE0_ST) 
       uc_wr_data0 <= 2'b11;
     else if (next_st == WRITE_CMDBYTE1_ST && current_st != WRITE_CMDBYTE1_ST) 
       uc_wr_data0 <= 2'b11;
     else if ((current_st == WRITE_DAT0_ST) && (load_xfer) && byte_cnt < (num_bytes)) //wuc =1, Master in wait_uC state
       uc_wr_data0 <= 2'b11;
     else
       uc_wr_data0 <= {uc_wr_data0[0],1'b0};
   
   assign uc_wr_data = uc_wr_data0[1];
   
   //I2c Read Strobe
   always @(posedge clk)
     if (rst)
       uc_rd_data0 <= 2'b00;
     else if (current_st == WRITE_DAT2_ST && (load_xfer) && byte_cnt < (num_bytes) )
       uc_rd_data0 <= 2'b11;
     else
       uc_rd_data0 <= {uc_rd_data0[0],1'b0};

   assign uc_rd_data = uc_rd_data0[1];
   
   
   always @(posedge clk)
     if (rst)
       byte_cnt <= 8'h0;
     else if ((current_st == WRITE_DAT0_ST) || (current_st == WRITE_CMDBYTE0_ST))
       if (xfer_complete0 && ~xfer_complete1)
	 byte_cnt <= byte_cnt + 1;
       else
	 byte_cnt <= byte_cnt;
     else if (current_st == WRITE_DAT2_ST)
       if (~xfer_complete0 && xfer_complete1)
	 byte_cnt <= byte_cnt + 1;
       else
	 byte_cnt <= byte_cnt;
     else 
       byte_cnt <= 8'h0;
   
    always @(posedge clk) begin
        if (rst) begin
            data_cnt    <= 3'd0;
        end
        else begin
            if ((current_st == WRITE_DAT0_ST) && (xfer_complete0 && ~xfer_complete1))
                data_cnt    <= data_cnt + 3'd1;
            else if (current_st == WRITE_DAT2_ST && (xfer_complete0 && ~xfer_complete1))  //different from byte_cnt
                data_cnt    <= data_cnt + 3'd1;
            else if (reset_cnt)
                data_cnt    <= 3'd0;	
        end
    end 
    
assign data_out = data_out0;

generate 
    if (DATA_BYTE_WIDTH == 8) begin
        always @(posedge clk)
            if (rst)
                data_out0 <= {8{1'b0}};
            else if (current_st == WRITE_DAT2_ST && (xfer_complete0 && ~xfer_complete1))
                data_out0 <= MODR;
    end
    else if (DATA_BYTE_WIDTH == 16) begin
        always @(posedge clk) begin
            if (rst) begin
                data_out0 <= {DATA_BYTE_WIDTH{1'b0}};
            end
            else if (current_st == WRITE_DAT2_ST && (xfer_complete0 && ~xfer_complete1)) begin
            	if (data_cnt == 0)      data_out0 <= {data_out0[DATA_BYTE_WIDTH-1:8], MODR};
            	else if (data_cnt == 1) data_out0 <= {MODR, data_out0[7:0]};
            	else data_out0 <= {DATA_BYTE_WIDTH{1'b0}};
            end
        end
    end
    else if (DATA_BYTE_WIDTH == 24) begin
        always @(posedge clk) begin
            if (rst) begin
                data_out0 <= {DATA_BYTE_WIDTH{1'b0}};
            end
            else if (current_st == WRITE_DAT2_ST && (xfer_complete0 && ~xfer_complete1)) begin
            	if (data_cnt == 0)      data_out0 <= {data_out0[DATA_BYTE_WIDTH-1:8], MODR};
            	else if (data_cnt == 1) data_out0 <= {data_out0[DATA_BYTE_WIDTH-1:16], MODR, data_out0[7:0]};
            	else if (data_cnt == 2) data_out0 <= {MODR, data_out0[15:0]};
            	else data_out0 <= {DATA_BYTE_WIDTH{1'b0}};
            end
        end
    end
    else if (DATA_BYTE_WIDTH == 32) begin
        always @(posedge clk) begin
            if (rst) begin
                data_out0 <= {DATA_BYTE_WIDTH{1'b0}};
            end
            else if (current_st == WRITE_DAT2_ST && (xfer_complete0 && ~xfer_complete1)) begin
            	if (data_cnt == 0)      data_out0 <= {data_out0[DATA_BYTE_WIDTH-1:8], MODR};
            	else if (data_cnt == 1) data_out0 <= {data_out0[DATA_BYTE_WIDTH-1:16], MODR, data_out0[7:0]};
            	else if (data_cnt == 2) data_out0 <= {data_out0[DATA_BYTE_WIDTH-1:24], MODR, data_out0[15:0]};
            	else if (data_cnt == 3) data_out0 <= {MODR, data_out0[23:0]};
            	else data_out0 <= {DATA_BYTE_WIDTH{1'b0}};
            end
        end
    end
endgenerate
   
////////////////////
// Soft Reset.
////////////////////

   always @(posedge clk or posedge i2c_soft_rst)
     if (rst | i2c_soft_rst)
       soft_rst_reg <= 4'hf;
     else
       soft_rst_reg <= {soft_rst_reg[2:0], 1'b0};

   assign soft_rst = soft_rst_reg[3];


   /*AUTOASCIIENUM("current_st", "current_st_ascii", "_ST")*/
   // Beginning of automatic ASCII enum decoding
   /*reg [79:0]		current_st_ascii;	// Decode of current_st
   always @(current_st) begin
      case ({current_st})
	IDLE_ST:       current_st_ascii = "idle      ";
	START_GEN0_ST: current_st_ascii = "start_gen0";
	WRITE_DAT0_ST: current_st_ascii = "write_dat0";
	START_GEN1_ST: current_st_ascii = "start_gen1";
	WRITE_DAT1_ST: current_st_ascii = "write_dat1";
	RESTART_ST:    current_st_ascii = "restart   ";
	WRITE_DAT2_ST: current_st_ascii = "write_dat2";
	STOP_GEN_ST:   current_st_ascii = "stop_gen  ";
	DONE_ST:       current_st_ascii = "done      ";
	default:       current_st_ascii = "%Error    ";
      endcase
   end*/
   // End of automatics

endmodule // i2c_master_ctrl

//////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// This   document  contains  proprietary information  which   is
// protected by  copyright. All rights  are reserved.  This notice
// refers to original work by Efinix, Inc. which may be derivitive
// of other work distributed under license of the authors.  In the
// case of derivative work, nothing in this notice overrides the
// original author's license agreement.  Where applicable, the 
// original license agreement is included in it's original 
// unmodified form immediately below this header.
//
// WARRANTY DISCLAIMER.  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND 
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH 
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES, 
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR 
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED 
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.
//
// LIMITATION OF LIABILITY.  
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY 
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT 
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY 
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT, 
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY 
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF 
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR 
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN 
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER 
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR 
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT 
//     APPLY TO LICENSEE.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   i2c_mstrslv_ctl_42020d0b46f7431cb398735cd4a68ca0.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      I2c controller main control logic
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns / 1ps

  
module i2c_mstrslv_ctl_42020d0b46f7431cb398735cd4a68ca0 
#(
    parameter I2C_FAST_MODE = 0,  // 1 - 400Mhz, 0 - 100Mhz
    parameter CLOCK_FREQ = 100,   // support 2 - 150Mhz, 1 - 100Mhz, 0 - 50Mhz 
    parameter SPIKE_FILTER_CYCLE = 2 // min - 1
)(
   //outputs 
   output [7:0] MBSR,             // I2C Status Register
   output reg [7:0] MODR,         // I2C Data Register outbound
   output reg sda_out,            // SDA output drive control
   output reg scl_out,             // SCL output drive control
   //inputs
   input restart,
   input [7:0] MBCR,              // I2C Control Register
   input [7:0] MADR,              // I2C Slave Address Register
   input [7:0] MIDR,              // I2C Data Register inbound
   input sda_in,                  // SDA input
   input scl_in,                  // SCL input
   input mbcr_wr,                 // MBCR is being written
   input uc_rd_data,              // Status uC read data register
   input uc_wr_data,              // Status uC wrote data register
   input mif_clr,                 // clear interrupt bit (mif)
   input mal_clr,                 // clear arbitration lost bit (mal)
   input clk                      // I2C state machine clock 2MHz/8MHz
  );
   

  //////////////////////////////////////
  // Internal parameters
  //////////////////////////////////////

   /////////////////////////////////////////////////////////////////////////////////////////
   // Timing:   Normal   Fast    (I2C Specification v2.1)
   // Fscl      100kHz   400kHz  SCL frequency
   // Th_scl    4.0us    0.6us   Min High period of SCL
   // Tl_scl    4.7us    1.3us   Min Low period of SCL
   // Thd:sta   4.0us    0.6us   Min hold time for a start condition
   // Tsu:sta   4.7us    0.6us   Min setup time for a repeated start condition
   // Tsu:dat   250ns    100ns   Min setup time for data
   // Thd:dat   300ns    300ns   Min hold time for data
   // Tsu:sto   4.0us    0.6us   Min setup time for a stop conditon
   // Tbuf      4.7us    1.3us   Min Bus free time between a stop/start condition
   //////////////////////////////////////////////////////////////////////////////////////////
   parameter integer CLOCK_PERIOD_NS = 1000/(CLOCK_FREQ);
   
   // 4 in HiE because 2 sync reg, 2 filter reg
   parameter integer T_HIGH = I2C_FAST_MODE ? ((600 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS) 
                                        : ((4000 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS);      // high period of SCL (Th_scl)
                                 				 // (4 in HiE, *60 in Hi, 1 in LoE) = 65 clk cycle for 100Mhz IP clock 
                                 				 // (4 in HiE, *400 in Hi, 1 in LoE) = 405 clk cycle for 100Mhz IP clock 
   parameter integer T_LOW = I2C_FAST_MODE ? ((1300 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS) 
                                        : ((4700 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS);       // low period of SCL (Tl_scl)
                                                 // (*130 in Lo, 1 in HiE) = 131 clk cycle for 100Mhz IP clock 
                                                 // (*470 in Lo, 1 in HiE) = 471 clk cycle for 100Mhz IP clock 
   parameter integer T_HD_START =  I2C_FAST_MODE ? ((600 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS) 
                                             : ((4000 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS);  // required start hold time (Thd:sta)
                                                 // (*60 in start) = 60 clk cycle for 100Mhz IP clock 
                                 				 // (*400 in start) = 400 clk cycle for 100Mhz IP clock 
   parameter integer T_SU_START = I2C_FAST_MODE ? ((600 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS)
                                            : ((4700 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS); // repeated start setup time (Tsu:sta)
                                                 // (*60 in Hi) = 60 clk cycle for 100Mhz IP clock 
                                 				 // (*470 in Hi) = 470 clk cycle for 100Mhz IP clock 
   parameter integer T_HD_DATA = I2C_FAST_MODE ? ((300 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS)
                                           : ((300 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS);   // required data hold time (Thd:dat)
                                 // (*30 in Lo) = 30 clk cycle for 100Mhz IP clock 
   parameter integer T_SU_STOP = I2C_FAST_MODE ? ((600 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS)
                                           : ((4000 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS);   // required stop setup time (Tsu:sto)
                                 // (2 in HiE, *60 in Hi) = 62 clk cycle for 100Mhz IP clock 
                                 // (2 in HiE, *400 in Hi) = 400 clk cycle for 100Mhz IP clock 
   parameter integer T_BUF = I2C_FAST_MODE ? ((1300 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS) 
                                       : ((4700 + CLOCK_PERIOD_NS-1) / CLOCK_PERIOD_NS);       // bus free time between a STOP/START condition
                                 // (*130 in Stop wait, 1 in Idle, 1 in Start) = 132
                                 // (*470 in Stop wait, 1 in Idle, 1 in Start) = 472
                                 
 // SCL State machine defines, onehot bit positions
  parameter ST_SCL_IDLE       = 3'd0,
            ST_SCL_START      = 3'd1,
            ST_SCL_LOW_EDGE   = 3'd2,
            ST_SCL_WAIT_uC    = 3'd3,
            ST_SCL_LOW        = 3'd4,
            ST_SCL_HIGH_EDGE  = 3'd5,
            ST_SCL_HIGH       = 3'd6,
            ST_SCL_STOP_WAIT  = 3'd7;
            
  parameter ST_SLV_SCL_IDLE     = 2'd0,
            ST_SLV_SCL_HOLD_SDA = 2'd1,
            ST_SLV_SCL_WAIT_uC  = 2'd2,
            ST_SLV_SCL_STOP_WAIT= 2'd3;
    
  // I2C State machine defines, onehot bit positions
  parameter ST_I2C_IDLE       = 3'd0,
            ST_I2C_HEADER     = 3'd1,
            ST_I2C_ACK_HEADER = 3'd2,
            ST_I2C_RCV_DATA   = 3'd3,
            ST_I2C_ACK_DATA   = 3'd4,
            ST_I2C_XMIT_DATA  = 3'd5,
            ST_I2C_WAIT_ACK   = 3'd6,
            ST_I2C_STOP       = 3'd7;

  // Bit counter conditions
  parameter BYTE_CNT = 4'd7;
  parameter XFER_DONE = 4'd8;

  //////////////////////////////////////
  // Internal nodes
  //////////////////////////////////////
  
  // active high sync reset
  wire rst;

  // MBCR control register inputs
  wire men;
  wire mien;
  reg  mstaS1;
  reg  mstaS0;
  reg  msta;
  wire mtx;
  wire txak;
  wire rsta;
  wire rsv1;
  wire rsv0;

  // MBSR status register outputs
  reg  mcf;
  reg  maas;
  reg  mbbS0;
  reg  mbb;
  reg  mal;
  reg  wucS0;
  wire wuc;
  wire wuc_negedge;
  reg  srw;
  reg  mif;
  reg  rxak;
  
  reg  master;

  // edge detector signals
  wire sclPosedge, sclNegedge;
  wire sdaPosedge, sdaNegedge;
  wire mstaPosedge;
  wire mstaNegedge;
  
  wire detectStart, detectStop;
  
  reg  genStart;
  reg  detect_start_pulse;
  reg  detectStartS0;
  
  reg  genStop;
  reg  detectStopS0;
  
  reg  rep_start;
  reg  mbcr_wr1;         //   Latched version of mbcr_wr
  reg  mbcr_wr2;         //   synced version of mbcr_wr1
  reg  rep_start1;
  reg  arb_lost;

  reg  [3:0] bitCount;
  reg  bitCountClr;
  
  reg  [10:0] mclkCount;
  reg  mclkCountClr;
  
  reg  [10:0] sclkCount;
  reg  sclkCountClr;

  reg  [7:0] mscl_state;
  reg  [7:0] mscl_next_state;
  reg  [3:0] sscl_state;
  reg  [3:0] sscl_next_state;

  reg  [7:0] i2c_state;
  reg  [7:0] i2c_next_state ;

  wire i2cHeaderEn;
  reg  [7:0] i2cHeader;
  wire addrMatch;
  
  wire sdaInData;
  reg  sdaInS0;
  reg  sdaOutNext;
  reg  sdaOutMaster;
  reg  sdaOutSlave, sdaOutSlaveNext;

  reg  sclOutNext;
  reg  sclOutSlave;
  
  reg sdaIn_0, sdaIn_1, sdaIn_int, sclIn_0, sclIn_1, sclIn_int;
  reg [3:0] sda_spike_cnt, scl_spike_cnt;
  wire sda_clear_cnt, sda_cnt_limit, sda_next, scl_clear_cnt, scl_cnt_limit, scl_next;
  reg sclIn_int_p1, sdaIn_int_p1, sda_next_p1;

  wire shiftOut;
  wire shiftRegEn;
  wire shiftRegLd;
  reg  [7:0] shiftReg;
  reg  uc_wr_data_p1;
  reg  genStart1;
  wire forceUpdate;
   
  //////////////////////////////////////////////////////////////////////////////
  // Module definition
  // MBCR Control Register. 
  // Update I2C control signals from control register
  // NOTE: The MBCR register should be synchronized into this clk domain.
  ///////////////////////////////////////////////////////////////////////////////
  assign men  = MBCR[7]; // I2C controller enable
  assign mien = MBCR[6]; // Interrupt enable 
  
  // Create a version of msta that gets reset if we loose arbitration
  always @ (posedge clk)
    if (rst | arb_lost)
      msta <= 1'b0;      // Master=1, Slave=0
    else if (mbcr_wr1)
      msta <= MBCR[5];   // Master/Slave mode Select
    
  assign mtx  = MBCR[4]; // Transmit/Receive mode: 0=rx, 1=tx
  assign txak = MBCR[3]; // Transmit Acknowledge: 0=ack, 1=noack
  assign rsta = MBCR[2]; // Repeated Start
  assign rsv1 = MBCR[1]; // Reserved
  assign rsv0 = MBCR[0]; // Reserved

  // Create sync active high reset when the I2C controller is disabled
  assign rst = ~men;
  
  //////////////////////////////////////////////////////////////////////////////
  // Double synchronization flops for sda
  //////////////////////////////////////////////////////////////////////////////    
    always @(posedge clk) begin
        if (rst) begin
            sdaIn_0 <= 1'b1; 
            sdaIn_1 <= 1'b1;
        end
        else begin
            sdaIn_0 <= sda_in; 
            sdaIn_1 <= sdaIn_0;
        end
    end

  //////////////////////////////////////////////////////////////////////////////
  // Generate sda spike filter logic 
  //////////////////////////////////////////////////////////////////////////////
    assign sda_clear_cnt = ~(sdaIn_1 ^ sda_next);
    
    always @(posedge clk) begin
        if (rst) begin
            sda_spike_cnt <= 4'h0;
        end
        else if (sda_clear_cnt) begin
            sda_spike_cnt <= 4'h0;    
        end
        else begin
            sda_spike_cnt <= sda_spike_cnt + 4'h1;
        end
    end
    
    assign sda_cnt_limit = (sda_spike_cnt > (SPIKE_FILTER_CYCLE - 1));
    
    always @(posedge clk) begin
        if (rst) begin
            sdaIn_int <= 1'b1;
        end
        else begin
            sdaIn_int <= sda_next_p1;
        end
    end

    always @(posedge clk) begin
        if (rst) begin
            sda_next_p1 <= 1'b1;
        end
        else begin
            sda_next_p1 <= sda_next;
        end
    end

    assign sda_next = sda_cnt_limit ? sdaIn_1 : sda_next_p1;
    
  //////////////////////////////////////////////////////////////////////////////
  // Double synchronization flops for scl
  //////////////////////////////////////////////////////////////////////////////    
    always @(posedge clk) begin
        if (rst) begin
            sclIn_0 <= 1'b1; 
            sclIn_1 <= 1'b1;
        end
        else begin
            sclIn_0 <= scl_in; 
            sclIn_1 <= sclIn_0;
        end
    end
    
  //////////////////////////////////////////////////////////////////////////////
  // Generate scl spike filter logic 
  //////////////////////////////////////////////////////////////////////////////
    assign scl_clear_cnt = ~(sclIn_1 ^ scl_next);
    
    always @(posedge clk) begin
        if (rst) begin
            scl_spike_cnt <= 4'h0;
        end
        else if (scl_clear_cnt) begin
            scl_spike_cnt <= 4'h0;    
        end
        else begin
            scl_spike_cnt <= scl_spike_cnt + 4'h1;
        end
    end
    
    assign scl_cnt_limit = (scl_spike_cnt > (SPIKE_FILTER_CYCLE - 1));
    
    always @(posedge clk) begin
        if (rst) begin
            sclIn_int <= 1'b1;
        end
        else begin
            sclIn_int <= scl_next;
        end
    end
    
    assign scl_next = scl_cnt_limit ? sclIn_1 : sclIn_int;

  //////////////////////////////////////////////////////////////////////////////
  // SCL & SDA posedge/negedge detection
  //////////////////////////////////////////////////////////////////////////////
  always @ (posedge clk)
    if (rst) begin
      sclIn_int_p1 <= 1'b1;
      sdaIn_int_p1 <= 1'b1;
    end
    else begin
      sclIn_int_p1 <= sclIn_int;
      sdaIn_int_p1 <= sdaIn_int;
    end

  assign sclPosedge = (~sclIn_int_p1 & sclIn_int);
  assign sclNegedge = (sclIn_int_p1 & ~sclIn_int);
  
  assign sdaPosedge = (~sdaIn_int_p1 & sdaIn_int);
  assign sdaNegedge = (sdaIn_int_p1 & ~sdaIn_int);

  //////////////////////////////////////////////////////////////////////////////
  // Master/Slave Mode selection latch.
  // msta posedge/negedge detection & synchronization
  /////////////////////////////////////////////////////////////////////////////
  always @ (posedge clk)
    if (rst)
      mstaS0 <= 1'b0;
    else
      mstaS0 <= msta;

  always @ (posedge clk)
    if (rst)
      mstaS1 <= 1'b0;
    else
      mstaS1 <= mstaS0;

  assign mstaPosedge = (~mstaS1 & mstaS0);
  assign mstaNegedge = (mstaS1 & ~mstaS0);
  
  //////////////////////////////////////////////////////////////////////////////
  // Generate start condition based on rising edge of msta. 
  //////////////////////////////////////////////////////////////////////////////
  always @ (posedge clk)
    if (rst)
      genStart <= 1'b0;
    else if (mstaPosedge)
      genStart <= 1'b1;
    else if (detectStartS0)
      genStart <= 1'b0;
      
  always @ (posedge clk)
    if (rst)
      genStart1 <= 1'b0;
    else
      genStart1 <= genStart;
  ////////////////////////////////////////////////
  // I2c Start condition. 
  // Start condition detection & synchronization
  /////////////////////////////////////////////////
  assign detectStart = sdaNegedge & sclIn_int;
  
  always @ (posedge clk)
    if (rst)
      detectStartS0 <= 1'b0;
    else
      detectStartS0 <= detectStart;
    
  //////////////////////////////////////////////////////////////////////////////
  // Generate stop condition - falling edge of MSTA or i2c state machine
  // requested stop and arbitration was not lost 
  //////////////////////////////////////////////////////////////////////////////
  always @ (posedge clk)
    if (rst)
      genStop <= 1'b0;
    else if ((mstaNegedge || i2c_state[ST_I2C_STOP]) && ~arb_lost)
      genStop <= 1'b1;
    else if (detectStopS0)
      genStop <= 1'b0;

   ///////////////////////////////
   //Detect Stop Condition.
   // Stop condition detect & synchronization
   ///////////////////////////////
   assign detectStop = sdaPosedge & sclIn_int;
   
   always @ (posedge clk)
     if (rst)
       detectStopS0 <= 1'b0;
     else
       detectStopS0 <= detectStop;
   
  //////////////////////////////////////////////////////////////////////////////
  // Master/Slave mode detection
  //////////////////////////////////////////////////////////////////////////////
  always @ (posedge clk)
    if (rst)
      master <= 1'b0;
    else if (~mbb) // bus not busy
      master <= msta;

  //////////////////////////////////////////////////////////////////////////////
  // SCL/SDA Generation state machine (Master Mode)                           //
  //////////////////////////////////////////////////////////////////////////////
  always @ (posedge clk)
    if (rst)
      mscl_state <= 8'h01;
    else
      mscl_state <= mscl_next_state;

   //////////////////////////////
   // Create SDA Master data
   // Shift Serial Data Out.
   //////////////////////////////

  always @ (posedge clk)
    if (rst)
      sdaOutMaster <= 1'b1;
    else if (i2c_state[ST_I2C_HEADER] || i2c_state[ST_I2C_XMIT_DATA])
      sdaOutMaster <= shiftOut;
    else if (mclkCount >= T_HD_DATA && i2c_state[ST_I2C_ACK_DATA])
      sdaOutMaster <= txak;
    else
      sdaOutMaster <= 1'b1;

 
  always @ (posedge clk)
    if (rst)
      mclkCount <= 11'd0;
    else if (mclkCountClr)
      mclkCount <= 11'd0;
    else
      mclkCount <= mclkCount + 1;

  always @ (posedge clk)
    if (rst)
      sda_out <= 1'b1;
    else
      sda_out <= (master) ? sdaOutNext : sdaOutSlaveNext;

  always @ (posedge clk)
    if (rst)
      scl_out <= 1'b1;
    else
      scl_out <= (master) ? sclOutNext : sclOutSlave;

   ///////////////////////////////////
   //MASTER I2c
   //SCL, and SDA transitions
   ///////////////////////////////////
   always @(*)
     begin
	//defaults 
	mscl_next_state = 8'h00;
	mclkCountClr = 1'b1; // clear or disable clock counter
	sclOutNext = 1'b1;
	sdaOutNext = sda_out;
	
	case (1'b1)
	  mscl_state[ST_SCL_IDLE] :
            begin
               sdaOutNext = 1'b1;
               // leave idle when master mode and bus not busy
               if (master & ~mbb & genStart)
                   mscl_next_state[ST_SCL_START] = 1'b1;
               else
                   mscl_next_state[ST_SCL_IDLE] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_START] :
            begin
               mclkCountClr = 1'b0; // enable clock count
               sdaOutNext = 1'b0;
               if (mclkCount == (T_HD_START-1))
                   mscl_next_state[ST_SCL_LOW_EDGE] = 1'b1;
               else
                   mscl_next_state[ST_SCL_START] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_LOW_EDGE] :
            begin
               sclOutNext = 1'b0;
               if (i2c_state[ST_I2C_ACK_DATA] ||
		           i2c_state[ST_I2C_ACK_HEADER] ||
		           i2c_state[ST_I2C_WAIT_ACK])
		           mscl_next_state[ST_SCL_WAIT_uC] = 1'b1;
               else
		           mscl_next_state[ST_SCL_LOW] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_WAIT_uC] :
            begin
               sclOutNext = 1'b0;
               if (genStop | uc_rd_data | uc_wr_data)
                   mscl_next_state[ST_SCL_LOW] = 1'b1;
               else
                   mscl_next_state[ST_SCL_WAIT_uC] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_LOW] :
            begin
               mclkCountClr = 1'b0; // enable clk count
               sclOutNext = 1'b0;
               // Wait the required SDA hold time
               if (mclkCount >= (T_HD_DATA-1))
		       begin
                   if (genStop)
                      sdaOutNext = 1'b0;
                   else if (rep_start | arb_lost)
                      sdaOutNext = 1'b1;
                   else
                      sdaOutNext = sdaOutMaster;
               end
               // Wait the required SCL low time
               if (mclkCount == (T_LOW-1))
               begin
                   if ((bitCount == BYTE_CNT) && arb_lost)
                      mscl_next_state[ST_SCL_IDLE] = 1'b1;
                   else
                      mscl_next_state[ST_SCL_HIGH_EDGE] = 1'b1;
               end
               else
                   mscl_next_state[ST_SCL_LOW] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_HIGH_EDGE] :
            begin
               // Check for clock stretching
               if (sclIn_int)
                   mscl_next_state[ST_SCL_HIGH] = 1'b1;
               else
                   mscl_next_state[ST_SCL_HIGH_EDGE] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_HIGH] :
            begin
               mclkCountClr = 1'b0; // enable clk count
               // Check for generate stop condition
               if (genStop) begin
		          if (mclkCount == (T_SU_STOP-1)) begin
			          mclkCountClr = 1'b1; // clear/disable clk count
			          sdaOutNext = 1'b1;
			          mscl_next_state[ST_SCL_STOP_WAIT] = 1'b1;
                  end
		          else
                      mscl_next_state[ST_SCL_HIGH] = 1'b1;
		       end
               // Check for repeated start
               else if (rep_start) begin
		          if (mclkCount == (T_SU_START-1)) begin
                      mclkCountClr = 1'b1; // clear/disable clk count
                      mscl_next_state[ST_SCL_START] = 1'b1;
                  end
		          else
                      mscl_next_state[ST_SCL_HIGH] = 1'b1;
		       end
               // Wait the required SCL high time
               else if (mclkCount == (T_HIGH-1))
                  mscl_next_state[ST_SCL_LOW_EDGE] = 1'b1;
               else
                  mscl_next_state[ST_SCL_HIGH] = 1'b1;
            end
	  
	  mscl_state[ST_SCL_STOP_WAIT] :
            begin
               mclkCountClr = 1'b0; // enable clk count
               // Wait the required bus free time
               if (mclkCount == (T_BUF-1)) 
                  mscl_next_state[ST_SCL_IDLE] = 1'b1;
               else
                  mscl_next_state[ST_SCL_STOP_WAIT] = 1'b1;
            end
	endcase
     end // always @ (*)
   
  
  //////////////////////////////////////////////////////////////////////////////
  // I2C Slave Mode 
  // SCL/SDA Generation state machine                            
  //////////////////////////////////////////////////////////////////////////////
   always @ (posedge clk)
     if (rst)
       sscl_state <= 4'h01;
     else
       sscl_state <= sscl_next_state;
   
  //Shift the slave data. 
   always @ (posedge clk)
     if (rst)
       sdaOutSlave <= 1'b1;
     else if (i2c_state[ST_I2C_XMIT_DATA])
       sdaOutSlave <= shiftOut;
     else if ((addrMatch && sclkCount >= T_HD_DATA && i2c_state[ST_I2C_ACK_HEADER]) || (sclkCount >= T_HD_DATA && i2c_state[ST_I2C_ACK_DATA]))
       sdaOutSlave <= txak;
     else
       sdaOutSlave <= 1'b1;
   
  always @ (posedge clk)
    if (rst)
      sclkCount <= 11'd0;
    else if (sclkCountClr)
      sclkCount <= 11'd0;
    else
      sclkCount <= sclkCount + 1;


   /////////////////////////////////////////
   // I2C Slave Controller FSM.
   /////////////////////////////////////////
   reg wait_uc, wait_uc_next;
   
   always @ (*)
     begin
	// Set defaults
	sscl_next_state = 4'b0000;
	sclkCountClr = 1'b1; // clear/disable clk counter
	sclOutSlave = 1'b1;
	sdaOutSlaveNext = sda_out;
	wait_uc_next = wait_uc;
	
	case (1'b1)
	  sscl_state[ST_SLV_SCL_IDLE] :
            begin         
               sdaOutSlaveNext = sdaOutSlave;
               
               if (~master && ((i2c_state[ST_I2C_ACK_HEADER] && addrMatch) || i2c_state[ST_I2C_ACK_DATA]) || (i2c_state[ST_I2C_WAIT_ACK] && ~sdaInData)) begin
		           sclkCountClr = 1'b0;
		       end
		           
               // leave idle when slave mode and SCL negedge
               if (~master && sclNegedge && ((i2c_state[ST_I2C_ACK_HEADER] && addrMatch && i2cHeader[0]) || i2c_state[ST_I2C_ACK_DATA] || (i2c_state[ST_I2C_WAIT_ACK] && ~sdaInData))) begin
		           sscl_next_state[ST_SLV_SCL_HOLD_SDA] = 1'b1;
		           sclkCountClr = 1'b1;
		           wait_uc_next = 1'b1;
		       end
               else if (~master && sclNegedge && (i2c_state[ST_I2C_ACK_HEADER] && addrMatch && ~i2cHeader[0])) begin
		           sscl_next_state[ST_SLV_SCL_HOLD_SDA] = 1'b1;
		           sclkCountClr = 1'b1;
		       end
               else begin
		           sscl_next_state[ST_SLV_SCL_IDLE] = 1'b1;
		       end
            end
          
	  sscl_state[ST_SLV_SCL_WAIT_uC] :
            begin
               sclOutSlave = 1'b0; // Clock Stretch
               wait_uc_next = 1'b0;
               
                   if (uc_rd_data || i2c_state[ST_I2C_IDLE])
		               sscl_next_state[ST_SLV_SCL_IDLE] = 1'b1;
                   else if (uc_wr_data)
		               sscl_next_state[ST_SLV_SCL_STOP_WAIT] = 1'b1;
                   else
		               sscl_next_state[ST_SLV_SCL_WAIT_uC] = 1'b1;
            end
            
      sscl_state[ST_SLV_SCL_HOLD_SDA] :
            begin
            	sclOutSlave = 1'b0; // Clock Stretch
                sclkCountClr = 1'b0; // enable clk count
                // Wait the required data setup time
                if (sclkCount == T_HD_DATA) begin
                	sdaOutSlaveNext = 1'b1;
                	
                	if (wait_uc) begin
                		sscl_next_state[ST_SLV_SCL_WAIT_uC] = 1'b1;
                    end
                    else begin
                        sscl_next_state[ST_SLV_SCL_IDLE] = 1'b1;
                    end
                end
                else
	                sscl_next_state[ST_SLV_SCL_HOLD_SDA] = 1'b1;
            end
	  
	  sscl_state[ST_SLV_SCL_STOP_WAIT] :
            begin
               sclOutSlave = 1'b0; // Maintain Clock Stretch
               sclkCountClr = 1'b0; // enable clk count
               // Wait the required data setup time
               if (sclkCount == T_HD_DATA) 
		           sscl_next_state[ST_SLV_SCL_IDLE] = 1'b1;
               else
		           sscl_next_state[ST_SLV_SCL_STOP_WAIT] = 1'b1;
            end
	  
	  default : sscl_next_state[ST_SLV_SCL_IDLE] = 1'b1;
	endcase
     end
     
    always @ (posedge clk)
    if (rst)
         wait_uc <= 1'b0;
    else //if (sclNegedge) // updates on negedge SCL
         wait_uc <= wait_uc_next;
   
   //////////////////////////////////////////////////////////////////////////////
   // I2C main state machine (Master/Slave Mode)                               //
   //////////////////////////////////////////////////////////////////////////////
   always @ (posedge clk)
     if (rst | detectStopS0)
       i2c_state <= 8'h01;
     else //if (sclNegedge) // updates on negedge SCL
       i2c_state <= i2c_next_state;
       
    always @ (posedge clk)
     if (rst) begin
     	 detect_start_pulse  <= 1'b0;
     end
     else begin
         if (sdaNegedge & sclIn_int) begin
     	     detect_start_pulse  <= 1'b1;
         end
         else if (sclPosedge) begin
     	     detect_start_pulse  <= 1'b0;
         end
     end
   
   // Create bit counter, counter increments on negedge of SCL
   always @ (posedge clk)
     if (rst)
       bitCount <= 4'd0;
     else if (bitCountClr & sclNegedge)
       bitCount <= 4'd0;
     else if (!detect_start_pulse & sclNegedge)
       bitCount <= bitCount + 1;
   
   // Sample valid SDA data on posedge SCL
   /*always @ (posedge clk)
     if (rst)
       sdaInData <= 1'b1;
     else if (sclPosedge)
       sdaInData <= sdaIn_int;*/
       
       assign sdaInData = sdaIn_int;

   /////////////////////////////////////
   //I2c Main State - FSM
   /////////////////////////////////////
   always @ (*)
     begin
	// Set defaults
	i2c_next_state = 8'h00;
	bitCountClr = 1'b1; // clear/disable bit counter
	
	case (1'b1)
	  i2c_state[ST_I2C_IDLE] :
            begin
               if (sclNegedge && detect_start_pulse) //(detectStartS0)
                   i2c_next_state[ST_I2C_HEADER] = 1'b1;
               else
                   i2c_next_state[ST_I2C_IDLE] = 1'b1;
            end
	  
	  i2c_state[ST_I2C_HEADER] :
            begin
               bitCountClr = 1'b0; // enable bit count
               if (detectStopS0)
                   i2c_next_state[ST_I2C_IDLE] = 1'b1;
               else if (bitCount == BYTE_CNT && sclNegedge)
                   i2c_next_state[ST_I2C_ACK_HEADER] = 1'b1;
               else                              
                   i2c_next_state[ST_I2C_HEADER] = 1'b1;
            end
	  
	  i2c_state[ST_I2C_ACK_HEADER] :
            begin
               if (arb_lost | detectStopS0)
                   i2c_next_state[ST_I2C_IDLE] = 1'b1;
               // ack has been received, check for master/slave
               else if (~sdaInData && sclNegedge) begin
		           // master mode, check mtx bit for direction
		           if (master)
                   begin
			           if (mtx)
			             i2c_next_state[ST_I2C_XMIT_DATA] = 1'b1;
			           else
			             i2c_next_state[ST_I2C_RCV_DATA] = 1'b1;
                   end
		           // slave mode, check for an address match
		           else if (addrMatch)
                   begin
			           if (i2cHeader[0])
			             i2c_next_state[ST_I2C_XMIT_DATA] = 1'b1;
			           else
			             i2c_next_state[ST_I2C_RCV_DATA] = 1'b1;
                   end
		           // not addressed, go back to IDLE
		           else
                       i2c_next_state[ST_I2C_IDLE] = 1'b1;
		       end
               // no ack received, generate stop if master
               else if (sdaInData && sclNegedge) begin
		          if (master)
                       i2c_next_state[ST_I2C_STOP] = 1'b1;
		          else
                       i2c_next_state[ST_I2C_IDLE] = 1'b1;
		       end
		       else begin
                   i2c_next_state[ST_I2C_ACK_HEADER] = 1'b1;
		       end
           end
	  
      i2c_state[ST_I2C_RCV_DATA] :
        begin
           if ((rep_start && master) || detectStartS0)
             bitCountClr = 1'b1; // disable bit count
           else
             bitCountClr = 1'b0; // enable bit count
	   
          if (detectStopS0)
            i2c_next_state[ST_I2C_IDLE] = 1'b1;
          else if ((rep_start && master && sclNegedge) || detectStartS0)
            i2c_next_state[ST_I2C_HEADER] = 1'b1;
          else if (bitCount == BYTE_CNT && sclNegedge)
            i2c_next_state[ST_I2C_ACK_DATA] = 1'b1; // Send an acknowledge
          else
            i2c_next_state[ST_I2C_RCV_DATA] = 1'b1;
        end
          
	  i2c_state[ST_I2C_ACK_DATA] :
            begin
                if (detectStopS0) begin 
                	i2c_next_state[ST_I2C_IDLE] = 1'b1;
                end
                else if (sclNegedge) begin
		            i2c_next_state[ST_I2C_RCV_DATA] = 1'b1;
		        end
		        else begin
		        	i2c_next_state[ST_I2C_ACK_DATA] = 1'b1;
		        end
            end
	  
	  i2c_state[ST_I2C_XMIT_DATA] :
            begin
               if ((rep_start && master) || detectStartS0)
		           bitCountClr = 1'b1; // disable bit count
               else
		           bitCountClr = 1'b0; // enable bit count
	       
               if (detectStopS0)
		           i2c_next_state[ST_I2C_IDLE] = 1'b1;
               else if ((rep_start && master && sclNegedge) || detectStartS0)
		           i2c_next_state[ST_I2C_HEADER] = 1'b1;
               else if (bitCount == BYTE_CNT && sclNegedge)
		           i2c_next_state[ST_I2C_WAIT_ACK] = 1'b1; // Wait for acknowledge
               else
		           i2c_next_state[ST_I2C_XMIT_DATA] = 1'b1;
            end
	  
	  i2c_state[ST_I2C_WAIT_ACK] :
           begin
               if (arb_lost | detectStopS0) begin
		           i2c_next_state[ST_I2C_IDLE] = 1'b1;
               // ack has been received, transmit next byte
               end
               else if (~sdaInData && sclNegedge) begin
		           i2c_next_state[ST_I2C_XMIT_DATA] = 1'b1;
               // no ack received, generate a stop if master
               end
               else if (sdaInData && sclNegedge) begin
                   if (master)
                      i2c_next_state[ST_I2C_STOP] = 1'b1;
                   else
                      i2c_next_state[ST_I2C_IDLE] = 1'b1;
               end
               else
		           i2c_next_state[ST_I2C_WAIT_ACK] = 1'b1;
            end
	  
	  i2c_state[ST_I2C_STOP] :
           begin
               if (sclNegedge) i2c_next_state[ST_I2C_IDLE] = 1'b1;
           end
	endcase
     end
   
   //////////////////////////////////////////////////////////////////////////////
   // I2C Header/Address Shift Register
   //
  assign i2cHeaderEn = i2c_state[ST_I2C_HEADER];

  always @ (posedge clk)
    if (rst)
      i2cHeader <= 8'd0;
    else if (i2cHeaderEn & sclNegedge)
      i2cHeader <= {i2cHeader[6:0], sdaInData};

  assign addrMatch = (i2cHeader[7:1] == MADR[7:1]);
      
  //////////////////////////////////////////////////////////////////////////////
  // I2C Data Shift Register
  //
  assign forceUpdate = (uc_wr_data &&
                        (mscl_state[ST_SCL_WAIT_uC] || sscl_state[ST_SLV_SCL_WAIT_uC]));
  assign shiftRegLd  = ((i2c_state[ST_I2C_IDLE] && master) ||
                        i2c_state[ST_I2C_WAIT_ACK] ||
                        (i2c_state[ST_I2C_ACK_HEADER] && i2cHeader[0] && ~master) ||
                        (i2c_state[ST_I2C_ACK_HEADER] && mtx && master));
  assign shiftRegEn  = ((i2c_state[ST_I2C_HEADER] && master) || i2c_state[ST_I2C_RCV_DATA] || i2c_state[ST_I2C_XMIT_DATA]) && !rep_start;

  always @ (posedge clk)
    if (rst) uc_wr_data_p1 <= 1'b0;
    else uc_wr_data_p1 <= uc_wr_data;
    
  // Microcontroller inbound data load, and shift register
  always @ (posedge clk)
    if (rst)
      shiftReg <= 8'd0;
    else if ((~genStart1 && genStart) | (~uc_wr_data && uc_wr_data_p1))
      shiftReg <= MIDR; // sample inbound data reg
    else if (shiftRegEn & sclNegedge)
      shiftReg <= {shiftReg[6:0], sdaInData};

  assign shiftOut = shiftReg[7];

  // Microcontroller outbound data
  always @ (posedge clk)
    if (rst)
      MODR <= 8'd0;
    else if (i2c_state[ST_I2C_ACK_DATA] || i2c_state[ST_I2C_WAIT_ACK])
      MODR <= shiftReg; // update outbound data reg

  //////////////////////////////////////////////////////////////////////////////
  // Arbitration Loss Detection 
  //
  // #1 It checks the master's outgoing SDA with the incoming SDA to
  // determine if control of the bus has been lost. When SCL is high, SDA is checked only
  // within  states IDLE, HEADER, XMIT_DATA, ACK_DATA and in
  // master mode. 
  // #2 When arbitration is lost, a reset is generated for the MSTA
  // bit. 
  // #3 When arbitration is lost, the mode is switched to slave and
  // SCL continues to be generated until the byte transfer is complete arb_lost
  // stays set until scl state machine goes to the IDLE state
  //
  always @ (posedge clk)
    if (rst || mscl_state[ST_SCL_IDLE])
      arb_lost <= 1'b0;
    else if (master && ~arb_lost && sclPosedge &&
             (i2c_state[ST_I2C_IDLE] || i2c_state[ST_I2C_HEADER] ||
              i2c_state[ST_I2C_XMIT_DATA] || i2c_state[ST_I2C_ACK_DATA])) begin
        if (sda_out == sdaIn_int)
           arb_lost <= 1'b0;	 
        else
           arb_lost <= 1'b1; 
    end
   
  /////////////////////////////
  //I2c Status Register 
  assign MBSR[7] = mcf;  // Data transfering bit
                         // '1' - transfer is complete
                         // '0' - transfer in progress. 
  assign MBSR[6] = maas; // Addressed as Slave bit
  assign MBSR[5] = mbb;  // Bus Busy bit
                         // '1' indicates the bus is busy
                         // '0' indicates the bus is idle. 
  assign MBSR[4] = mal;  // Arbitration lost
                         // This bit is set by microcontroller when arbitration loss.
  assign MBSR[3] = wuc;  // Wait microcontroller
  assign MBSR[2] = srw;  // Slave Read/Write bit
  assign MBSR[1] = mif;  // Interrupt bit
  assign MBSR[0] = rxak; // Receive Acknowledge bit

  // MCF - Data transferring bit
  // While one byte of data is being transferred, this bit is cleared. It 
  // is set by the falling edge of the 9th clock of a byte transfer.
  always @ (posedge clk)
    if (rst)
      mcf <= 1'b0;
    else if ((bitCount == XFER_DONE) && (sclNegedge))
      mcf <= 1'b1;
    else //if (wuc_negedge) // exiting WAIT_uC state
      mcf <= 1'b0;

  // MAAS - Addressed As Slave Bit
  // When its own specific address (MADR) matches the I2C Address, this bit 
  // is set. The CPU is interrupted provided the MIEN is set. Then the CPU 
  // needs to check the SRW bit and set its TX-RX mode accordingly. Writing 
  // to the MBCR clears this bit
  always @ (posedge clk)
    if (rst | mbcr_wr)
      maas <= 1'b0;
    else if (i2c_state[ST_I2C_ACK_HEADER])
      maas <= addrMatch;

wire mbcr_wr_nedge;
  
  always @( posedge (clk) )
  begin
    if (rst) begin
      mbcr_wr1 <= 1'b0;
      mbcr_wr2 <= 1'b0;
      rep_start1<= 1'b0;
    end
    else begin
      mbcr_wr1 <= mbcr_wr;
      mbcr_wr2 <= mbcr_wr_nedge;
      rep_start1<= rep_start;
    end
  end
  
  assign mbcr_wr_nedge = ~mbcr_wr && mbcr_wr1;

  // Set the rep_start signal true whenever the mbcr is
  // written to with the rsta bit set. This signal is
  // cleared when we reach the header state, stop is detected
  // or arbitration ois lost.
  always @( posedge (clk) )
  begin
    if (rst | (i2c_state[ST_I2C_HEADER] && sclNegedge ) | mal)
      rep_start <= 1'b0;
    else
    begin
      if (mbcr_wr2 && rsta) // rsta was set last time mbcr was written
        rep_start <= 1'b1;
      else if (detectStopS0)
        rep_start <= 1'b0;
    end
  end
  

  // MBB - Bus Busy Bit
  // This bit indicates the status of the bus. This bit is set when a 
  // START signal is detected and cleared when a stop signal is detected. 
  // It is also cleared on reset.
  always @ (posedge clk)
    if (rst)
      mbb <= 1'b0;
    else if (detectStartS0)
      mbb <= 1'b1;
    else if (detectStopS0)
      mbb <= 1'b0;
    
  // sample mbb
  always @ (posedge clk)
    if (rst)
      mbbS0 <= 1'b0;
    else
      mbbS0 <= mbb;

  // MAL - Arbitration Lost Bit
  // This bit is set when the arbitration procedure is lost. Arbitration 
  // is lost when:
  //      1. SDA is sampled low when the master drives high during addr or 
  //         data transmit cycle
  //      2. SDA is sampled low when the master drives high during the 
  //         acknowledge bit of a data receive cycle
  //      3. A start cycle is attempted when the bus is busy
  //      4. A repeated start is requested in slave mode
  //      5. A stop condition is detected when the master did not requested.
 
  always @ (posedge clk)
    if (rst | mal_clr)
      mal <= 1'b0;
    else if (master)
      begin
        if ((arb_lost) ||                // Condition 1,2 above
            (mbbS0 && genStart) ||      // Condition 3 above
            (detectStopS0 && !genStop)) // Condition 5 above
          mal <= 1'b1;
      end
    else if (rep_start) // Condition 4 above
      mal <= 1'b1;

  // WUC - Wait microcontroller. 
  // This bit is set when waiting on the microcontroller to read/write to the data
  // register MBDR.
  assign wuc = (mscl_state[ST_SCL_WAIT_uC] || sscl_state[ST_SLV_SCL_WAIT_uC]);

  // sample wuc
  always @ (posedge clk)
    if (rst)
      wucS0 <= 1'b0;
    else
      wucS0 <= wuc;

  assign wuc_negedge = (wucS0 & ~wuc);
                        
  // SRW - Slave Read/Write Bit
  // When MAAS is set, SRW indicates the value of the R/W command bit of 
  // the calling address sent from the master. This bit is only valid when 
  // a complete transfer has occurred and no other transfers have been 
  // initiated. The CPU uses this bit to set the slave transmit/receive mode.
  always @ (posedge clk)
    if (rst)
      srw <= 1'b0;
    else if (i2c_state[ST_I2C_ACK_HEADER] && addrMatch)
      srw <= i2cHeader[0];

  // MIF - M-bus Interrupt
  // The MIF bit is set when an interrupt is pending, which causes a 
  // processor interrupt request provided MIEN is set. MIF is set when:
  //      1. Byte transfer is complete (set at the falling edge of the 9th clock
  //      2. MAAS is set when in slave receive mode
  //      3. Arbitration is lost
  // This bit is cleared by reset and software writting a '0'to it.
  always @ (posedge clk)
    if (rst | mif_clr)
      mif <= 1'b0;
    else if (mien && (mcf || (maas && ~i2cHeader[0] && ~master) || mal))
      mif <= 1'b1;

  // RXAK - Received Acknowledge
  // RXAK contains the value of SDA during the acknowledge bit of a bus 
  // cycle. If =0, then an acknowledge signal has been received, if 1, 
  // then no acknowledge has been received.  This bit is set at reset.
  always @ (posedge clk)
    if (rst)
      rxak <= 1'b1;  // Reset to no ack state
    else if ((i2c_state[ST_I2C_ACK_HEADER] ||
              i2c_state[ST_I2C_ACK_DATA] ||
              i2c_state[ST_I2C_WAIT_ACK]) &&
             sclNegedge)
      rxak <= sdaInData;

endmodule 

//////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// This   document  contains  proprietary information  which   is
// protected by  copyright. All rights  are reserved.  This notice
// refers to original work by Efinix, Inc. which may be derivitive
// of other work distributed under license of the authors.  In the
// case of derivative work, nothing in this notice overrides the
// original author's license agreement.  Where applicable, the 
// original license agreement is included in it's original 
// unmodified form immediately below this header.
//
// WARRANTY DISCLAIMER.  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND 
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH 
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES, 
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR 
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED 
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.
//
// LIMITATION OF LIABILITY.  
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY 
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT 
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY 
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT, 
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY 
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF 
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR 
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN 
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER 
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR 
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT 
//     APPLY TO LICENSEE.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   i2c_slave_ctl_42020d0b46f7431cb398735cd4a68ca0.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      I2c slave controller top module
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************
`resetall
`timescale 1ns / 1ps
  
module i2c_slave_ctl_42020d0b46f7431cb398735cd4a68ca0
#(
    parameter SLAVE_ADDR = 8'h54,
    parameter DATA_BYTE_WIDTH = 32,  // max - 32, range - 8, 16, 24, 32
    parameter I2C_FAST_MODE = 1,  // 1 - 400khz, 0 - 100khz
    parameter CLOCK_FREQ = 100,   // support 2 - 150Mhz, 1 - 100Mhz, 0 - 50Mhz 
    parameter SPIKE_FILTER_CYCLE = 2
) (
    //I2c Interfacing.  
    output wire	                      sda_out,
    output wire                       sda_oe,
    input 			                  sda_in,
    
    output wire                       scl_out,
    output wire                       scl_oe,
    input 			                  scl_in,
    
    //Microcontroller interface
    input                             clk,  //IP clock
    input                             rst,   //IP reset
    input                             read,     //Read Strobe from Microcontroller
    input                             write,    //write Strobe from Microcontroller
    input [DATA_BYTE_WIDTH-1:0]       din,		//32-bits from Microcontroller / User Logic FSM. 
    output wire [DATA_BYTE_WIDTH-1:0] data_out,	    //32-bits data to Microcontroller/User Logic. 
    output reg  [7:0]                 command_byte,
    
    output wire                       busy,
    output reg                        ready_to_wr,  //user should write only when this bit is high, else the previous data will be override
    output reg                        ready_to_rd,
    output wire                       rddata_valid  
    
   );

   parameter [2:0] IDLE_WRST      = 3'h0;
   parameter [2:0] GEN_WR_STROBE  = 3'h1;
   parameter [2:0] GEN_TX_DONE    = 3'h2;
     
   parameter [2:0] IDLE_RDST      = 3'h0;
   parameter [2:0] READ_CMDBYTE_ST= 3'h1;
   parameter [2:0] RESTART_ST     = 3'h2;
   parameter [2:0] WAIT_4_READ_ST = 3'h3;
   parameter [2:0] READ_ST        = 3'h4;
   parameter [2:0] GEN_RD_STROBE  = 3'h5;
   parameter [2:0] GEN_RD_VALID   = 3'h6;
     
   reg [2:0] current_rdst, next_rdst; 
   reg [1:0] current_wrst, next_wrst;
   reg [DATA_BYTE_WIDTH-1:0] data_in;
   reg [7:0] MBCR, data_out0, data_out1, data_out2, data_out3;
   reg [2:0] tx_byte_cnt, rx_byte_cnt;
   reg mbcr_wr0, mbcr_wr1, mbcr_write_p1, wuc_p1, slave_write_p1;
   wire [7:0] MIDR, MBSR, MODR;
   wire uc_rd_data, uc_wr_data, mbcr_write; 
   wire wuc, srw, slave_write;
   wire tx_complete; 
   wire write_p, read_p;
   reg rx_xfer;
   wire reset_bytecnt;

   assign reset_bytecnt = (current_rdst == IDLE_RDST) ? 1'b1 : 1'b0;   
   
   assign sda_oe = ~sda_out;
   assign scl_oe = 1'b0;
   
   // I2c status register bit
   assign srw           = MBSR[2];
   assign wuc           = MBSR[3];
   assign busy          = MBSR[5];
   
   assign slave_write   = srw;
   
  /////////////////////////////////////
   //Sychronizer
   //Fast2Slow Domain
   /////////////////////////////////////
   pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0 u_pgfts_wrflag
     (
      // Outputs
      .data_out           (write_p),
      // Inputs
      .clk                (clk),
      .rst                (rst),
      .data_in            (write));
   
   pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0 u_pgfts_rdflag
     (
      // Outputs
      .data_out           (read_p),
      // Inputs
      .clk                (clk),
      .rst                (rst),
      .data_in            (read));
   
   /////////////////////////////
   //I2c Controller
   /////////////////////////////
   
   i2c_mstrslv_ctl_42020d0b46f7431cb398735cd4a68ca0 #(
      .I2C_FAST_MODE (I2C_FAST_MODE),
      .CLOCK_FREQ (CLOCK_FREQ),
      .SPIKE_FILTER_CYCLE (SPIKE_FILTER_CYCLE)
   ) u_i2c_slv_ctl
     (
      // Outputs
      .MBSR             (MBSR),		    //I2c Status Register.
      .MODR             (MODR),		//I2c Data Register
      .sda_out          (sda_out),		//SDA output drive control.
      .scl_out          (scl_out),		//SCL output drive control.
      // Inputs
      .restart          (1'b0),
      .MBCR             (MBCR),		//i2c control register.
      .MADR             (SLAVE_ADDR),	//I2c Slave Address Register
      .MIDR             (MIDR),		    //I2c Data Register Inbound.
      .sda_in           (sda_in),		//SDA Input.
      .scl_in           (scl_in),		//SCL input.
      .mbcr_wr          (mbcr_write_p1),	//MBCR is being written
      .uc_rd_data       (uc_rd_data),		//Status uC read data register.
      .uc_wr_data       (uc_wr_data),		//Status uC wrote data register.
      .mif_clr		    (1'b0),			//Clear Interrupt Bit
      .mal_clr		    (1'b0),			//Clear Arbitration Lost Bit.
      .clk				(clk));		//2MHz clock.
      
    always @(posedge clk) begin
        if (rst) begin
            ready_to_wr <= 1'b0;
            ready_to_rd <= 1'b0;
        end
        else begin
        	if (write_p) begin
                ready_to_wr <= 1'b0;
            end
            else if ((slave_write && wuc && ~wuc_p1 && tx_byte_cnt == 0) || (((tx_byte_cnt == (DATA_BYTE_WIDTH/8)) && wuc && ~wuc_p1) && current_wrst !=IDLE_WRST)) begin
                ready_to_wr <= 1'b1;
            end
            
        	if (read_p) begin
                ready_to_rd <= 1'b0;
            end
            else if ((current_rdst == WAIT_4_READ_ST)) begin
            //else if (current_rdst == GEN_RD_STROBE && busy && (next_rdst == GEN_RD_VALID || next_rdst == READ_ST) && (rx_byte_cnt == (DATA_BYTE_WIDTH/8))) begin
            //else if ((current_rdst == READ_ST && rx_byte_cnt == 0) || (current_rdst == GEN_RD_STROBE && busy && next_rdst == GEN_RD_VALID)) begin
                ready_to_rd <= 1'b1;
            end
        end
    end
   
    //----- for write------------------
    //microcontroller write data to be sent out to I2C master
    assign MIDR = data_in[7:0];
    assign tx_complete = (next_wrst == GEN_TX_DONE);
    assign uc_wr_data  = (next_wrst == GEN_TX_DONE) || ((next_wrst == GEN_WR_STROBE) && (current_wrst == IDLE_WRST));
    assign mbcr_write  = ~mbcr_wr1 && mbcr_wr0;
    
    always @(posedge clk) begin
        if (rst) begin
            MBCR <= 8'h00;
        end
        else if (mbcr_write) begin
            MBCR <= 8'hc0;
        end
    end
    
    always @(posedge clk) begin
        if (rst) begin
            mbcr_wr0 <= 1'b0;
            mbcr_wr1 <= 1'b0;
            mbcr_write_p1 <= 1'b0;
            wuc_p1   <= 1'b0;
            slave_write_p1  <= 1'b0;
        end
        else begin
            mbcr_wr0 <= 1'b1;
            mbcr_wr1 <= mbcr_wr0;
            mbcr_write_p1 <= mbcr_write;
            wuc_p1   <= wuc;
            slave_write_p1  <= slave_write;
        end
    end
   
generate if (DATA_BYTE_WIDTH > 8) begin
    always @(posedge clk) begin
        if (rst) begin
            data_in <= {DATA_BYTE_WIDTH{1'b0}};
        end
        else if (write_p) begin
            data_in <= din;
        end
        else if (tx_complete) begin
            data_in <= {8'h00, data_in[DATA_BYTE_WIDTH-1:8]};
        end
    end
end
else begin
    always @(posedge clk) begin
        if (rst) begin
            data_in <= 8'b0;
        end
        else begin
            data_in <= din;
        end
    end
end
endgenerate
    
    always @(posedge clk) begin
        if (rst) begin
            tx_byte_cnt <= 3'h0;
        end
        else if (uc_wr_data) begin
            tx_byte_cnt <= tx_byte_cnt + 3'h1;
        end
        else if (current_wrst == IDLE_WRST || (tx_complete && (tx_byte_cnt == (DATA_BYTE_WIDTH/8)))) begin
            tx_byte_cnt <= 3'h0;
        end
    end
    
    always @(posedge clk) begin
	    if (rst) begin
	        current_wrst <= IDLE_WRST;
	    end
	    else begin
	        current_wrst <= next_wrst;
	    end
    end
     
    always @(*) begin
        next_wrst = IDLE_WRST;
        case (current_wrst)
	        IDLE_WRST: begin
	           if (write_p) 
	               next_wrst = GEN_WR_STROBE;
	           else
	               next_wrst = IDLE_WRST;
	        end
	        
	        GEN_WR_STROBE: begin
	            if (~busy) begin
	                next_wrst = IDLE_WRST;
	            end
	            else if (wuc && (tx_byte_cnt < (DATA_BYTE_WIDTH/8))) begin 
	                next_wrst = GEN_TX_DONE;
	            end
	            else if (wuc && (tx_byte_cnt == (DATA_BYTE_WIDTH/8))) begin 
	                next_wrst = IDLE_WRST;
	            end
	            else begin
	                next_wrst = GEN_WR_STROBE;
	            end
	        end

	        GEN_TX_DONE: begin
	            next_wrst = GEN_WR_STROBE;
	        end
        endcase
    end
    //----- for write------------------

    //----- for read------------------
    //microcontroller read data from I2C master
    generate begin
    	if (DATA_BYTE_WIDTH == 32)
            assign data_out = rddata_valid ? {data_out3, data_out2, data_out1, data_out0} : {32{1'b0}};
        else if (DATA_BYTE_WIDTH == 24)
        	assign data_out = rddata_valid ? {data_out2, data_out1, data_out0} : {24{1'b0}};
        else if (DATA_BYTE_WIDTH == 16)
        	assign data_out = rddata_valid ? {data_out1, data_out0} : {16{1'b0}};
        else if (DATA_BYTE_WIDTH == 8)
        	assign data_out = rddata_valid ? data_out0 : {8{1'b0}};
    end
    endgenerate
    
    assign uc_rd_data   = (next_rdst == GEN_RD_STROBE && current_rdst == READ_ST) || (next_rdst == RESTART_ST && current_rdst == READ_CMDBYTE_ST);
    assign rddata_valid = (current_rdst == GEN_RD_VALID);
    
    always @(posedge clk) begin
        if (rst) begin
            data_out0 <= 8'h0;
            data_out1 <= 8'h0;
            data_out2 <= 8'h0;
            data_out3 <= 8'h0;
            command_byte <= 8'h0;
        end
        else if (uc_rd_data) begin
        	if (next_rdst == RESTART_ST) begin
                command_byte <= MODR;
            end
        	else if (rx_byte_cnt == 3'h0) begin
                data_out0 <= MODR;
            end
        	else if (rx_byte_cnt == 3'h1) begin
                data_out1 <= MODR;
            end
        	else if (rx_byte_cnt == 3'h2) begin
                data_out2 <= MODR;
            end
        	else if (rx_byte_cnt == 3'h3) begin
                data_out3 <= MODR;
            end
        end
    end
    
    always @(posedge clk) begin
        if (rst) begin
            rx_byte_cnt <= 3'h0;
        end
        else if (uc_rd_data && (current_rdst == READ_ST)) begin
            rx_byte_cnt <= rx_byte_cnt + 3'h1;
        end
        else if (reset_bytecnt) begin
            rx_byte_cnt <= 3'h0;
        end
    end
    
    always @(posedge clk) begin
	    if (rst) begin
	        current_rdst <= IDLE_RDST;
	    end
	    else begin
	        current_rdst <= next_rdst;
	    end
    end
    
    always @(posedge clk) begin
	    if (rst) begin
	        rx_xfer <= 1'b0;
	    end
	    else if (current_rdst == READ_ST) begin
	        rx_xfer <= 1'b1;
	    end
	    else if (~busy) begin
	        rx_xfer <= 1'b0;
	    end
    end
     
    always @(*) begin
        next_rdst = IDLE_RDST;
        case (current_rdst)
	        IDLE_RDST: begin
	           if (wuc && ~wuc_p1 && rx_xfer) begin 
	               next_rdst = WAIT_4_READ_ST;
	           end
               else if (wuc && ~wuc_p1 && ~rx_xfer && !slave_write) begin
 	               next_rdst = READ_CMDBYTE_ST;
 	           end
	           else begin
	               next_rdst = IDLE_RDST;
	           end
	        end
	        
	        READ_CMDBYTE_ST : begin
	            next_rdst = RESTART_ST; 
	        end
	        
	        RESTART_ST: begin
	            if (wuc) begin
	                if (slave_write) begin // address byte of slave write, dont need assert ready_to_rd and rddata_valid
	                    next_rdst = IDLE_RDST;
	                end
	                else begin
	                    next_rdst = WAIT_4_READ_ST;
	                end
	            end
	            else begin
	                next_rdst = RESTART_ST;
	            end
	        end
	        
	        WAIT_4_READ_ST: begin
	            if (read_p) begin
	                next_rdst = READ_ST; 	
	            end
	            else begin
	                next_rdst = WAIT_4_READ_ST;
	            end
	        end
	        
	        READ_ST: begin
	            next_rdst = GEN_RD_STROBE; 
	        end
	        
	        GEN_RD_STROBE: begin
	            if (~busy) begin
	            	next_rdst = GEN_RD_VALID;
	            end
	            //else if (srw) begin   // address byte of slave write, dont need assert ready_to_rd and rddata_valid
	            //    next_rdst = IDLE_RDST;
	            //end
	            else if (~wuc && wuc_p1 && (rx_byte_cnt == (DATA_BYTE_WIDTH/8))) begin
	            	next_rdst = GEN_RD_VALID;
                end
                else if (wuc) begin
	                next_rdst = READ_ST;
	            end
	            else begin
	                next_rdst = GEN_RD_STROBE;	  
	            end
	        end
	        
	        GEN_RD_VALID: begin
	            next_rdst = IDLE_RDST;	    
	        end
        endcase
    end
    //----- for read------------------

endmodule // i2c_master_ctrl

//////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// This   document  contains  proprietary information  which   is
// protected by  copyright. All rights  are reserved.  This notice
// refers to original work by Efinix, Inc. which may be derivitive
// of other work distributed under license of the authors.  In the
// case of derivative work, nothing in this notice overrides the
// original author's license agreement.  Where applicable, the 
// original license agreement is included in it's original 
// unmodified form immediately below this header.
//
// WARRANTY DISCLAIMER.  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND 
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH 
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES, 
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR 
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED 
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.
//
// LIMITATION OF LIABILITY.  
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY 
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT 
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY 
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT, 
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY 
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF 
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR 
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN 
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER 
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR 
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT 
//     APPLY TO LICENSEE.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      pulse generator
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns / 1ps


module pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0
    (
     //outputs.
     output reg data_out,     //slow clock signal

     //inputs
     input 	clk,           //system clock
     input 	rst,           //active high reset. 
     input 	data_in        //fast clock signal
     );
//Parameters
   
//Internal Signals
   reg data0;
   reg data1,data2,data3,data4;
   


   always @(posedge clk or posedge data_in)
     if (data_in)
       data0 <= 1'b1;
     else if (rst)
       data0 <= 1'b0;
     else if (data2 & ~data3)
       data0 <= 1'b0;
   

   always @(posedge clk)
     if (rst)
       begin
	  data1 <= 1'b0;
	  data2 <= 1'b0;
	  data3 <= 1'b0;
	  data4 <= 1'b0;
       end

     else    
       begin
	  data1 <= data0;
	  data2 <= data1;
	  data3 <= data2;
	  data4 <= data3;
       end
   
   always @(posedge clk)
     if (rst)
       data_out <= 1'b0;
     else if (data3 & ~data4)
       data_out <= 1'b1;
     else
       data_out <= 1'b0;
   
   
endmodule // pulse_gen_fts_42020d0b46f7431cb398735cd4a68ca0

//////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// This   document  contains  proprietary information  which   is
// protected by  copyright. All rights  are reserved.  This notice
// refers to original work by Efinix, Inc. which may be derivitive
// of other work distributed under license of the authors.  In the
// case of derivative work, nothing in this notice overrides the
// original author's license agreement.  Where applicable, the 
// original license agreement is included in it's original 
// unmodified form immediately below this header.
//
// WARRANTY DISCLAIMER.  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND 
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH 
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES, 
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR 
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED 
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.
//
// LIMITATION OF LIABILITY.  
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY 
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT 
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY 
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT, 
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY 
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF 
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR 
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN 
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER 
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR 
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT 
//     APPLY TO LICENSEE.
//
/////////////////////////////////////////////////////////////////////////////